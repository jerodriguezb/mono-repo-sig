import React, {
  useCallback,
  useEffect,
  useMemo,
  useState,
} from 'react';
import {
  Alert,
  Autocomplete,
  Box,
  Button,
  Divider,
  Grid,
  MenuItem,
  Snackbar,
  Stack,
  Step,
  StepLabel,
  Stepper,
  TextField,
  Typography,
} from '@mui/material';
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import timezone from 'dayjs/plugin/timezone';
import customParseFormat from 'dayjs/plugin/customParseFormat';
import DocumentItemsTable from './DocumentItemsTable.jsx';
import { fetchProveedores } from '../../api/proveedores.js';
import { listarDocumentos, createDocumento } from '../../api/documentos.js';
import { searchProductos, updateProductoStock } from '../../api/producserv.js';
import { useAuth } from '../../context/AuthContext.jsx';

dayjs.extend(utc);
dayjs.extend(timezone);
dayjs.extend(customParseFormat);

const ARG_TIMEZONE = 'America/Argentina/Buenos_Aires';
dayjs.tz.setDefault(ARG_TIMEZONE);

const steps = ['Tipo de movimiento', 'Detalles del documento'];

const DOCUMENT_TYPES = [
  { value: 'R', label: 'Remito' },
  { value: 'NR', label: 'Nota de Recepción' },
  { value: 'AJ', label: 'Ajuste de Inventario' },
];

const createEmptyItem = () => ({ cantidad: '', producto: null, codprod: '' });

const extractPrefijoDigits = (sequence, tipo) => {
  if (!tipo) return null;
  if (!sequence) return null;
  const cleaned = sequence.replace(/\s+/g, '').toUpperCase();
  if (!cleaned.startsWith(tipo)) return null;
  const digits = cleaned.slice(tipo.length);
  if (!/^\d{1,4}$/.test(digits)) return null;
  return digits.padStart(4, '0');
};

const formatSequence = (tipo, digits) => {
  if (!tipo) return '';
  const padded = digits ? digits.padStart(4, '0') : '0001';
  return `${tipo}${padded}`;
};

const formatNumeroPreview = (value) => {
  if (value === undefined || value === null || value === '') return '';
  return String(value).padStart(8, '0');
};

const mapAxiosError = (error) => (
  error?.response?.data?.err?.message
    || error?.response?.data?.message
    || error?.message
    || 'Ocurrió un error inesperado'
);

export default function DocumentWizard() {
  const [activeStep, setActiveStep] = useState(0);
  const [selectedType, setSelectedType] = useState('');
  const [providers, setProviders] = useState([]);
  const [providersLoading, setProvidersLoading] = useState(false);
  const [selectedProvider, setSelectedProvider] = useState(null);
  const [items, setItems] = useState([createEmptyItem()]);
  const [prefijoDigits, setPrefijoDigits] = useState('0001');
  const [sequenceDisplay, setSequenceDisplay] = useState('');
  const [nroDocumentoManual, setNroDocumentoManual] = useState('');
  const [nroDocumentoPreview, setNroDocumentoPreview] = useState('');
  const [fechaRemito, setFechaRemito] = useState(() => dayjs().tz(ARG_TIMEZONE));
  const [fechaTexto, setFechaTexto] = useState(() => dayjs().tz(ARG_TIMEZONE).format('DD/MM/YYYY'));
  const [observaciones, setObservaciones] = useState('');
  const [errors, setErrors] = useState({});
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'success' });
  const [saving, setSaving] = useState(false);
  const [productOptions, setProductOptions] = useState([]);
  const [productLoading, setProductLoading] = useState(false);

  const { userId } = useAuth();

  const isRemito = selectedType === 'R';
  const isAutogeneratedType = selectedType === 'NR' || selectedType === 'AJ';

  const secuenciaEditable = isRemito;

  const currentSequence = useMemo(
    () => formatSequence(selectedType, prefijoDigits),
    [selectedType, prefijoDigits],
  );

  useEffect(() => {
    if (!selectedType) {
      setSequenceDisplay('');
      return;
    }

    const digits = isRemito ? prefijoDigits : '0001';
    setSequenceDisplay(formatSequence(selectedType, digits));
    if (!isRemito) setPrefijoDigits('0001');
  }, [selectedType, isRemito, prefijoDigits]);

  const loadProviders = useCallback(async () => {
    setProvidersLoading(true);
    try {
      const data = await fetchProveedores({ limite: 500 });
      setProviders(data?.proveedores || []);
    } catch (error) {
      setSnackbar({ open: true, severity: 'error', message: mapAxiosError(error) });
    } finally {
      setProvidersLoading(false);
    }
  }, []);

  const fetchProductos = useCallback(async (search) => {
    setProductLoading(true);
    try {
      const data = await searchProductos({ search, limite: 20 });
      setProductOptions(data?.producservs || []);
    } catch (error) {
      setSnackbar({ open: true, severity: 'error', message: mapAxiosError(error) });
    } finally {
      setProductLoading(false);
    }
  }, []);

  const fetchNextNumero = useCallback(async (tipo) => {
    try {
      const data = await listarDocumentos({ tipo, limite: 1, sort: 'nroDocumento:desc' });
      const ultimo = data?.documentos?.[0]?.nroDocumento;
      const siguiente = Number.isFinite(Number(ultimo)) ? Number(ultimo) + 1 : 1;
      setNroDocumentoPreview(formatNumeroPreview(siguiente));
    } catch (error) {
      setNroDocumentoPreview('');
      const detalle = mapAxiosError(error);
      setSnackbar({
        open: true,
        severity: 'warning',
        message: detalle
          ? `No se pudo obtener el próximo número automáticamente. ${detalle}`
          : 'No se pudo obtener el próximo número automáticamente.',
      });
    }
  }, []);

  useEffect(() => {
    if (activeStep === 1) {
      if (providers.length === 0) loadProviders();
      fetchProductos('');
      if (isAutogeneratedType) fetchNextNumero(selectedType);
    }
  }, [activeStep, fetchProductos, fetchNextNumero, isAutogeneratedType, loadProviders, providers.length, selectedType]);

  const handleTypeAdvance = () => {
    if (!selectedType) {
      setErrors({ tipo: 'Selecciona un tipo de movimiento para continuar.' });
      return;
    }
    setErrors({});
    setActiveStep(1);
  };

  const handleSequenceChange = (event) => {
    const value = event.target.value.toUpperCase();
    setSequenceDisplay(value);
    const digits = extractPrefijoDigits(value, selectedType);
    if (digits) {
      setPrefijoDigits(digits);
      setErrors((prev) => ({ ...prev, sequence: undefined }));
    }
  };

  const handleItemsFieldChange = (index, field, value) => {
    setItems((prev) => {
      const updated = [...prev];
      const item = { ...updated[index] };
      if (field === 'cantidad') {
        item.cantidad = value;
      } else if (field === 'producto') {
        item.producto = value;
        if (value?.codprod) item.codprod = value.codprod;
      } else if (field === 'codprod') {
        item.codprod = value;
      }
      updated[index] = item;
      return updated;
    });
  };

  const handleAddItem = () => setItems((prev) => [...prev, createEmptyItem()]);

  const handleRemoveItem = (index) => {
    setItems((prev) => prev.filter((_, position) => position !== index));
  };

  const resetForm = () => {
    setActiveStep(0);
    setSelectedType('');
    setSelectedProvider(null);
    setItems([createEmptyItem()]);
    setPrefijoDigits('0001');
    setSequenceDisplay('');
    setNroDocumentoManual('');
    setNroDocumentoPreview('');
    const hoy = dayjs().tz(ARG_TIMEZONE);
    setFechaRemito(hoy);
    setFechaTexto(hoy.format('DD/MM/YYYY'));
    setObservaciones('');
    setErrors({});
  };

  const validateForm = () => {
    const validationErrors = {};
    let isValid = true;

    const prefijo = extractPrefijoDigits(sequenceDisplay || currentSequence, selectedType);
    if (!selectedType) {
      validationErrors.tipo = 'Selecciona un tipo de movimiento válido.';
      isValid = false;
    }

    if (!prefijo) {
      validationErrors.sequence = 'La secuencia debe respetar el formato letra + cuatro dígitos.';
      isValid = false;
    } else {
      setPrefijoDigits(prefijo);
    }

    if (isRemito && nroDocumentoManual) {
      const trimmed = nroDocumentoManual.toString().trim();
      if (!/^\d{1,8}$/.test(trimmed)) {
        validationErrors.nroDocumento = 'El número debe contener hasta 8 dígitos numéricos.';
        isValid = false;
      }
    }

    if (!selectedProvider) {
      validationErrors.proveedor = 'Selecciona un proveedor.';
      isValid = false;
    }

    if (!fechaRemito) {
      validationErrors.fechaRemito = 'La fecha del documento es obligatoria.';
      isValid = false;
    }

    if (!items.length) {
      validationErrors.itemsMessage = 'Agrega al menos un ítem.';
      isValid = false;
    }

    const itemErrors = items.map((item) => {
      const rowErrors = {};
      const cantidadNumber = Number(item.cantidad);
      if (!Number.isFinite(cantidadNumber) || cantidadNumber <= 0) {
        rowErrors.cantidad = 'Cantidad inválida.';
        isValid = false;
      }
      if (!item.producto?._id) {
        rowErrors.producto = 'Selecciona un producto.';
        isValid = false;
      }
      if (!item.codprod || !item.codprod.toString().trim()) {
        rowErrors.codprod = 'Ingresa el código de producto.';
        isValid = false;
      }
      return rowErrors;
    });

    validationErrors.items = itemErrors;
    setErrors(validationErrors);
    return isValid;
  };

  const handleSave = async () => {
    if (!validateForm()) {
      setSnackbar({ open: true, severity: 'error', message: 'Revisa los campos obligatorios antes de grabar.' });
      return;
    }

    setSaving(true);
    try {
      const fechaISO = fechaRemito ? dayjs(fechaRemito).tz(ARG_TIMEZONE).format('YYYY-MM-DD') : undefined;
      const payload = {
        tipo: selectedType,
        proveedor: selectedProvider?._id,
        fechaRemito: fechaISO,
        prefijo: prefijoDigits,
        observaciones: observaciones?.trim() || undefined,
        items: items.map((item) => ({
          cantidad: Number(item.cantidad),
          producto: item.producto._id,
          codprod: item.codprod.toString().trim(),
        })),
      };

      if (isRemito && nroDocumentoManual) {
        payload.nroDocumento = Number(nroDocumentoManual);
      }

      if (userId) payload.usuario = userId;

      const { documento } = await createDocumento(payload);

      const cantidadesPorProducto = new Map();
      const productoMetadata = new Map();
      items.forEach((item) => {
        if (!item.producto?._id) return;
        const id = item.producto._id;
        const cantidad = Number(item.cantidad) || 0;
        cantidadesPorProducto.set(id, (cantidadesPorProducto.get(id) || 0) + cantidad);
        if (!productoMetadata.has(id)) productoMetadata.set(id, item.producto);
      });

      const updateTasks = Array.from(cantidadesPorProducto.entries()).map(([productoId, cantidad]) => {
        const base = productoMetadata.get(productoId);
        const stockActual = Number(base?.stkactual ?? 0);
        const nuevoStock = stockActual - cantidad;
        return updateProductoStock(productoId, { stkactual: nuevoStock });
      });

      const resultadosStock = await Promise.allSettled(updateTasks);
      const fallos = resultadosStock.filter((resultado) => resultado.status === 'rejected');

      if (fallos.length > 0) {
        setSnackbar({
          open: true,
          severity: 'warning',
          message: 'El documento se guardó, pero algunas actualizaciones de stock fallaron.',
        });
      } else {
        const visible = documento?.numeroVisible || formatNumeroPreview(documento?.nroDocumento);
        setSnackbar({
          open: true,
          severity: 'success',
          message: visible
            ? `Documento ${visible} guardado y stock actualizado correctamente.`
            : 'Documento guardado y stock actualizado correctamente.',
        });
      }

      resetForm();
    } catch (error) {
      setSnackbar({ open: true, severity: 'error', message: mapAxiosError(error) });
    } finally {
      setSaving(false);
    }
  };

  const handleSnackbarClose = () => {
    setSnackbar((prev) => ({ ...prev, open: false }));
  };

  return (
    <Stack spacing={3}>
      <Stepper activeStep={activeStep} alternativeLabel>
        {steps.map((label) => (
          <Step key={label}>
            <StepLabel>{label}</StepLabel>
          </Step>
        ))}
      </Stepper>

      {activeStep === 0 && (
        <Stack spacing={2}>
          <Typography variant="subtitle1">Seleccioná el tipo de movimiento</Typography>
          <TextField
            select
            label="Tipo de documento"
            value={selectedType}
            onChange={(event) => {
              setSelectedType(event.target.value);
              setErrors({});
            }}
            helperText="Las opciones se corresponden con los tipos habilitados en el backend."
            error={Boolean(errors.tipo)}
          >
            {DOCUMENT_TYPES.map((option) => (
              <MenuItem key={option.value} value={option.value}>
                {option.label}
              </MenuItem>
            ))}
          </TextField>
          {errors.tipo && (
            <Typography variant="body2" color="error">{errors.tipo}</Typography>
          )}
          <Box display="flex" justifyContent="flex-end" gap={2}>
            <Button
              variant="contained"
              onClick={handleTypeAdvance}
              disabled={!selectedType}
            >
              Continuar
            </Button>
          </Box>
        </Stack>
      )}

      {activeStep === 1 && (
        <Stack spacing={3}>
          <Grid container spacing={2}>
            <Grid item xs={12} md={6}>
              <TextField
                label="Tipo seleccionado"
                value={selectedType}
                fullWidth
                disabled
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <TextField
                label="Secuencia"
                value={sequenceDisplay || currentSequence}
                onChange={handleSequenceChange}
                fullWidth
                inputProps={{ maxLength: 6 }}
                disabled={!secuenciaEditable}
                helperText={errors.sequence || (secuenciaEditable
                  ? 'Formato sugerido: letra + cuatro dígitos (ej.: R0001).'
                  : 'El sistema genera automáticamente la secuencia visible.')}
                error={Boolean(errors.sequence)}
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <TextField
                label="Número de documento"
                fullWidth
                value={isAutogeneratedType ? nroDocumentoPreview : nroDocumentoManual}
                onChange={(event) => {
                  setNroDocumentoManual(event.target.value.replace(/[^\d]/g, ''));
                  setErrors((prev) => ({ ...prev, nroDocumento: undefined }));
                }}
                inputProps={{ maxLength: 8 }}
                disabled={isAutogeneratedType}
                helperText={errors.nroDocumento || (isRemito
                  ? 'Opcional: ingresa un número manual de hasta 8 dígitos.'
                  : 'Se mostrará el próximo número asignado por el backend.')}
                error={Boolean(errors.nroDocumento)}
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <TextField
                label="Fecha de remito"
                value={fechaTexto}
                onChange={(event) => {
                  const valor = event.target.value;
                  setFechaTexto(valor);
                  if (!valor) {
                    setFechaRemito(null);
                    return;
                  }
                  const parsed = dayjs(valor, 'DD/MM/YYYY', true);
                  if (parsed.isValid()) {
                    setFechaRemito(parsed.tz(ARG_TIMEZONE));
                    setErrors((prev) => ({ ...prev, fechaRemito: undefined }));
                  } else {
                    setErrors((prev) => ({ ...prev, fechaRemito: 'Ingresá la fecha con el formato dd/mm/aaaa.' }));
                  }
                }}
                placeholder="dd/mm/aaaa"
                fullWidth
                error={Boolean(errors.fechaRemito)}
                helperText={errors.fechaRemito || 'Formato: dd/mm/aaaa (zona horaria de Argentina).'}
                inputProps={{ inputMode: 'numeric', pattern: '\\d{2}/\\d{2}/\\d{4}' }}
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <Autocomplete
                loading={providersLoading}
                options={providers}
                value={selectedProvider}
                onChange={(event, newValue) => {
                  setSelectedProvider(newValue);
                  setErrors((prev) => ({ ...prev, proveedor: undefined }));
                }}
                getOptionLabel={(option) => option?.razonsocial || ''}
                isOptionEqualToValue={(option, value) => option?._id === value?._id}
                renderInput={(params) => (
                  <TextField
                    {...params}
                    label="Proveedor"
                    error={Boolean(errors.proveedor)}
                    helperText={errors.proveedor || 'Se consulta directamente al backend para mantener la lista actualizada.'}
                  />
                )}
              />
            </Grid>
            <Grid item xs={12}>
              <TextField
                label="Observaciones"
                value={observaciones}
                onChange={(event) => setObservaciones(event.target.value)}
                fullWidth
                multiline
                minRows={2}
              />
            </Grid>
          </Grid>

          <Divider />

          <Stack spacing={1}>
            <Typography variant="subtitle1">Detalle de ítems</Typography>
            <DocumentItemsTable
              items={items}
              onFieldChange={handleItemsFieldChange}
              onAddItem={handleAddItem}
              onRemoveItem={handleRemoveItem}
              onProductSearch={fetchProductos}
              productOptions={productOptions}
              productLoading={productLoading}
              errors={errors.items || []}
            />
            {errors.itemsMessage && (
              <Alert severity="error">{errors.itemsMessage}</Alert>
            )}
          </Stack>

          <Box display="flex" justifyContent="space-between" gap={2}>
            <Button variant="outlined" onClick={() => setActiveStep(0)} disabled={saving}>
              Volver
            </Button>
            <Button variant="contained" onClick={handleSave} disabled={saving}>
              {saving ? 'Guardando…' : 'Grabar'}
            </Button>
          </Box>
        </Stack>
      )}

      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert severity={snackbar.severity} onClose={handleSnackbarClose} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Stack>
  );
}

